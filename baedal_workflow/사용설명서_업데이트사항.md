# QuickEats 주문 API V2 리팩토링 보고서

## 목표
기존 V1 API의 한계를 해결하기 위해 **QuickEats 주문 처리 마이크로서비스 V2**를 리팩토링했습니다.
주요 해결 과제: 모호한 상태 전이, 동시성 문제(Race Condition), 멱등성 부족, N+1 쿼리 문제.

## 구현된 변경 사항

### 1. V2 API 구조 신설
- API 버전 관리를 위해 별도의 네임스페이스 `orders/api/v2/`를 생성했습니다.
- V1(`api/v1/`)과 V2(`api/v2/`)가 공존하도록 라우팅을 설정했습니다.

### 2. 행위 기반 리소스 (Action-oriented Resources)
기존의 모호한 `PUT /orders/{id}` 대신 명시적인 **Action Endpoint**를 도입했습니다.
- **구현된 엔드포인트**:
    - `POST /payment`: 결제 처리
    - `POST /cancellation`: 주문 취소
    - `POST /acceptance`: 주문 접수
    - `POST /rejection`: 주문 거절
    - `POST /preparation-complete`: 조리 완료
    - `POST /pickup`: 픽업 완료
    - `POST /delivery`: 배달 완료
- **효과**: 유효하지 않은 상태 전이(예: 조리 중 취소)를 원천 차단했습니다.

### 3. 모델 업데이트
`orders/models.py`의 `Order` 모델을 확장했습니다.
- **상태 추가**: `REJECTED`(거절), `IN_TRANSIT`(배달중), `DELIVERED`(완료), `READY_FOR_PICKUP`(픽업대기).
- **버전 필드**: 낙관적 락을 위한 `version` 필드 추가.

### 4. 낙관적 락 (Optimistic Locking)
`OrderV2ViewSet`에 동시성 제어 로직을 구현했습니다.
- **ETag 생성**: `MD5(order-{id}-v{version})` 해시 사용.
- **If-Match 검증**: 요청 헤더의 ETag와 현재 리소스 버전을 비교.
- **충돌 처리**: 버전 불일치 시 `412 Precondition Failed` 반환.
- **버전 관리**: 상태 변경 성공 시 `version` 자동 증가.

### 5. 멱등성 (Idempotency)
`IdempotencyKey` 모델과 `@idempotent` 데코레이터를 구현했습니다.
- **메커니즘**: 고유 키(Key)에 대한 응답 결과를 저장(캐싱)합니다.
- **적용**: 결제(`POST /payment`) 엔드포인트에 적용.
- **효과**: 네트워크 오류 등으로 인한 중복 요청 시, 중복 결제를 방지하고 저장된 응답을 반환.

### 6. N+1 문제 해결 (Side-loading)
- **관계 설정**: `Restaurant`, `Rider` 모델을 추가하고 `Order`와 연결했습니다.
- **사이드로딩**: `?include=restaurant,rider` 파라미터 지원.
- **최적화**: `select_related`를 사용하여 단 1번의 쿼리로 모든 연관 데이터를 조회.
- **응답 구조**: `{ "results": [...], "included": {...} }` 형태의 Compound Document 반환.

---

## 검증 결과

### 자동화 테스트 (`tests_v2.py`)
Django Test Runner를 통해 모든 상태 전이 시나리오를 검증했습니다.
- **결과**: `PASSED` (9/9 tests)
- 각 단계별 상태 변경 및 `If-Match` 헤더 검증 완료.

### 수동 검증 (브라우저)
Django REST Framework의 Browsable API를 통해 접근성을 확인했습니다.
- **목록 조회**: `http://127.0.0.1:8000/api/v2/orders/`
- **액션 수행**: `http://127.0.0.1:8000/api/v2/orders/{id}/payment/` (입력 폼 제공됨)

![액션 엔드포인트 스크린샷](/C:/Users/  **미정** 곧 추가예정 )

### 동시성 및 멱등성 검증 (`attack.py`)
`attack.py` 스크립트로 Race Condition 및 중복 요청 시나리오를 테스트했습니다.
- **동시성 결과**: 고객(취소) vs 사장(접수) 동시 요청 시, 늦은 요청은 `412` 에러로 차단됨 (성공).
- **멱등성 결과**: 동일한 키로 중복 결제 요청 시, `version` 증가 없이 캐시된 응답 반환 (성공).

### N+1 검증 (`tests_nplus1.py`)
- **쿼리 수**: 데이터 개수(N)와 상관없이 **단 1회**의 쿼리만 실행됨을 확인.
- **구조**: `included` 필드에 식당 및 라이더 정보가 정상적으로 포함됨.

---

##  사용자 실행 가이드 (수동 테스트)

실제 서비스 흐름을 브라우저에서 체험해보는 방법입니다:

1.  **주문 생성**: `http://127.0.0.1:8000/api/v2/orders/` 접속.
    -   입력 폼에 `restaurant_name="치킨집"` 입력 후 **POST**.
    -   생성된 ID 기억 (예: 15). 상태: `pending_payment`.

2.  **결제 (고객)**: `http://127.0.0.1:8000/api/v2/orders/15/payment/` 접속.
    -   입력 폼에 `payment_method="card"`, `amount=20000` 입력 후 **POST**.
    -   **결과**: 상태가 `pending_acceptance`(접수대기)로 변경됨.

3.  **접수 (사장님)**: `http://127.0.0.1:8000/api/v2/orders/15/acceptance/` 접속.
    -   **POST** 버튼 클릭.
    -   **결과**: 상태가 `preparing`(조리중)으로 변경됨.

4.  **조리 완료 (사장님)**: `http://127.0.0.1:8000/api/v2/orders/15/preparation-complete/` 접속.
    -   **POST** 버튼 클릭.
    -   **결과**: 상태가 `ready_for_pickup`(픽업대기)으로 변경됨.

5.  **픽업 (라이더)**: `http://127.0.0.1:8000/api/v2/orders/15/pickup/` 접속.
    -   **POST** 버튼 클릭.
    -   **결과**: 상태가 `in_transit`(배달중)으로 변경됨.

6.  **배달 완료 (라이더)**: `http://127.0.0.1:8000/api/v2/orders/15/delivery/` 접속.
    -   **POST** 버튼 클릭.
    -   **결과**: 상태가 `delivered`(배달완료)로 변경됨.

**참고: 각 단계 사이에 `http://127.0.0.1:8000/api/v2/orders/15/` 로 접속하여 상태 값(`status`)과 버전(`version`)이 바뀌는 것을 확인해 보세요.**

**유의사항: URL 오른쪽 끝편의 숫자 15는 단순히 주문별 부여된 숫자입니다. 원하는 숫자로 진행가능 합니다.**
