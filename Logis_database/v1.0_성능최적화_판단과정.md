### Logisflow 성능 최적화 설계(어떻게 효율적으로 변화했는가)

**1. 초기 설계: 정규화**

**설계 의도**

Logisflow 초기에는 데이터 무결성을 가장 중요하게 두고 설계했다
배송의 기본 정보와 배송 상태 이력은 성격이 다르다고 판단해 아래와 같이 분리했다

> shipments : 배송의 고정 정보
> shipment_updates : 배송 상태 변경 이력 > 1:N 관계로 정규화

이 구조는:
배송 상태 변경 이력을 정확히 보존할 수 있고
데이터 중복 없이 관리할 수 있다는 장점이 있었다

**문제 발생**

하지만 실제 서비스에서는 배송 목록 화면에서
항상 **각 배송의 최신 상태(Current Status)**가 필요했다.
그래서 쿼리는 자연스럽게 다음 패턴으로 흘러갔다

```
shipments 조회

각 row마다 shipment_updates에서

timestamp가 가장 최신인 row를 찾음

JOIN + 정렬 사용
```

**성능 이슈**

데이터가 쌓이자 문제가 드러났다
shipment_updates 테이블에 대한 `Full Table Scan` 또는 `정렬`(sort) 비용 발생 
특히 최신 상태를 찾기 위한 `ORDER BY timestamp DESC`

**한계 및 결론**

데이터 양 증가 -> 조회 속도 급격히 저하
benchmark_v1에서 Tuples Out, CPU 사용량 증가 현상 확인
- 정규화는 논리적으로는 완벽했지만, 읽기 성능에는 불리한 구조였다.
---

**2. 인덱스를 최적화 하자**

적용한 인덱스 개념

- B-Tree 인덱스 활용

Full Scan(O(N)) -> B-Tree 탐색(O(log N))
> 시간복잡도에서 우위

- 카디널리티 고려하기

`shipment_id`는 중복도가 낮고(고유), 선택도가 높음
인덱스 키로 적합하다 판단
```
WHERE u.shipment_id = s.shipment_id  -- 단일 인덱스 정상 사용
```

**한계 및 결론**

최신 상태 조회 쿼리가 인덱스 스캔만으로 처리
- benchmark_v2에서:
`시간 대폭 감소`
`TPS 개선`
`Tuples out 낭비되는 읽기 거의 없음`

> 엄청난 성능 개선이 있었지만, 대시보드 트래픽 집중 시 CPU 부담 여전히 존재함
> 읽기 성능만 보기때문에 트레이드 오프를 해야했다

**3. 비정규화**

#### Trade_OFF

```완벽한 정규화를 버리고, 읽기 성능을 더 높이는 최적화 하자```
- 읽기(Read) 성능을 위해 쓰기(Write) 비용을 희생하는 비정규화를 채택
- Shipments 테이블에 중복 데이터(current_status, last_updated_at)를 저장할 컬럼을 추가
```
SELECT SQL_NO_CACHE s.shipment_id, s.current_status
    FROM shipments s LIMIT 1000
```

**결론**
정규화된 구조는 데이터 무결성과 확장성 측면에서는 이상적이었지만, 
메인 대시보드처럼 읽기(Read)가 압도적으로 많은 화면에서는 반복적인 JOIN과 인덱스 랜덤 접근으로
인해 성능 한계를 드러냈다

**`TradeOFF`를 통해 배송 상태의 최신 값만큼은 shipments 테이블에 직접 보관하는 비정규화를 적용했고,**
**조회 쿼리를 단순화하여 CPU 사용량과 응답 시간을 획기적으로 단축하였다**
