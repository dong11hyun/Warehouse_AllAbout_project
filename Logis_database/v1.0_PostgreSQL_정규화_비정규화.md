### (PostgreSQL) 대용량 데이터베이스 정규화 vs 비정규화 성능 최적화
 
##### 1. 개요 및 문제 상황
- Service: Logis-Flow (실시간 화물 추적 SaaS)
- Problem: 
  - 데이터 무결성을 위해 **제3정규형(3NF)**을 준수하여 설계.
  - 데이터 급증(50만 건 이상)에 따라 대시보드 로딩 속도가 수십 초 단위로 지연되는 심각한 병목 발생.
- Goal PostgreSQL의 모니터링 도구를 활용하여 병목 원인을 시각적으로 분석하고, 비정규화를 통해 조회 성능을 극대화한다.

##### 2. Tech Stack & Environment
- Database PostgreSQL 18 (Monitoring: pgAdmin 4 Dashboard)
- Language Python 3.9
- Dataset
  - `Shipments` (화물): 50,000 Rows
  - `Shipment_Updates` (로그): 500,000 Rows
- Visualization Tool: pgAdmin 4 Dashboard (TPS, Tuples out, Active Sessions 모니터링)

##### 3. 핵심 병목 (Bottleneck) 분석
- 시나리오: 화물 1건당 수십 건의 상태 변경 로그가 존재하며, 목록 조회 시 각 화물의 '가장 최신 상태' 1건을 결합해야 함.
- SQL Logic: `ORDER BY timestamp DESC LIMIT 1` 서브쿼리가 N번(화물 수만큼) 반복 실행됨.
- PostgreSQL 지표 분석:
  - Tuples out 급증: 인덱스 부재 시, 최신값 1개를 찾기 위해 전체 파티션을 스캔함.
  - High CPU: 정렬(Sorting) 연산으로 인한 CPU 점유율 상승.

##### 4. 성능 테스트 및 지표 변화 (Dashboard Monitoring)

**정규화 모델**
> 현상: 가장 최신의 상태를 찾기 위해 매 행마다 로그 테이블 Full Scan 발생
- **⏱️ 소요 시간**: **63.76 초** (Timeout 발생 위험)
- **🔥 CPU Usage**: **96.1 %** (Single Core Saturation)
- **📊 Dashboard**: 
  - `Tuples out` 수치 폭발 (비효율적 I/O)
  - `Active Sessions`가 줄어들지 않음, 계속 'Active' 상태로 누적

**인덱스 최적화 (Index Tuning)**
> 해결: `CREATE INDEX ON shipment_updates(shipment_id, timestamp DESC)` 적용
- **⏱️ 소요 시간**: **0.13 초** (약 500배 향상)
- **🔥 CPU Usage**: **49.9 %**
- **📊 Dashboard**: 
  - `Tuples out` 대폭 감소.
  - 하지만 대량 조회 시 여전히 Index Scan에 의한 CPU 부하 존재.

**비정규화 적용 (Solution)**
> 해결: `Shipments` 테이블에 `current_status`, `last_updated_at` 중복 컬럼 추가
- **⏱️ 소요 시간**: **0.0045 초** (인덱스 대비 30배 추가 향상)
- **🔥 CPU Usage**: **1.6 %** (Idle 상태 유지)
- **📊 Dashboard**: 
  - `TPS (Transactions Per Second)` 그래프가 수직 상승 (처리량 극대화).
  - `Tuples out` 실제 조회된 행의 개수와 정확히 일치 (낭비되는 Read 0).
  - `Tuples in`  상태 변경 시에만 소폭 상승

##### 5. 트레이드오프 및 결론

**PostgreSQL 대시보드를 통해 확인한 인사이트:**
1. 인덱스는 강력하다: 적절한 인덱싱만으로도 63초를 0.13초로 줄일 수 있다. 트래픽이 적당하다면 이것이 1차 방어선이자 최적의 선택이다.
2. 비정규화는 조회 비용을 '0'으로 만든다: 
   - 대시보드 지표에서 `CPU`와 `Tuples out`가 바닥을 치는 것을 확인.
   - 조회 빈도가 압도적으로 높은 시스템(Dashboard)에서는 데이터 중복을 허용하는 비정규화가 가장 효율적이다.
3. 책임의 이동: 
   - 성능 이득을 얻은 대신, 데이터 정합성의 책임이 DB 엔진(FK 제약조건 등)에서 애플리케이션(개발자)로 넘어왔다.
   - 추후 과제: 데이터 불일치 방지를 위한 Transaction `Atomic` 처리** 및 이벤트 기반 비동기 동기화 구현 필요.