### <아키텍처를 이렇게 설계한 머릿속 생각과 근거를 정리>

> **가장 중요하게 생각하는 것 : 안정성 있는 로직(결제, 유저), 빠른 응답(실시간 경매)**

**1. HTTP 요청과 WebSocket 연결의 분리**

**설계 의도**

NeighborBid는 '돈이 오가는 결제'와 '0.1초를 다투는 경매'라는 두 가지 상반된 성격의 기능이 공존한다.
따라서 단일 프로토콜을 고집하지 않고, 기능의 목적에 따라 통신 방식을 분리했다.

> Track A (HTTP): 결제, 로그인 등 "기록의 정확성"이 중요한 기능
> Track B (WebSocket): 실시간 호가 등 "속도와 동시성"이 중요한 기능

**선택 근거 (왜 둘다 사용하고, 분리했나?)**

1. **HTTP (Stateless) 채택 이유**
   - **안정성:** 결제나 회원가입 처리에 있어 연결 유지 비용 없이 표준화된 요청/응답 구조가 훨씬 안정적이다.
   - **자원 효율:** 모든 요청을 웹소켓으로 처리할 경우, 단순 조회 시에도 불필요한 서버 메모리(연결 유지 비용)를 점유하게 된다.

2. **WebSocket (Stateful) 채택 이유**
   - **Low Latency(낮은 지연):** HTTP 폴링(새로고침) 방식은 실시간 경쟁에 부적합하다. 소켓은 헤더 오버헤드 없이 데이터를 즉시 Push 할 수 있다.
   - **User Experience:** 화면 깜빡임 없는 '단톡방' 같은 부드러운 호가 업데이트 경험을 제공 가능하다.

- Stateless : 상태저장 & 서버기억 둘 다 없음 / 확장성 좋음, 서버 부담 낮음 (HTTP는 보통 이쪽)

- Stateful : 상태저장 & 서버기억 둘 다 있음 / 확장성 떨어지고, 서버 부담은 높아짐

**결론**
**"돈은 안정적인 HTTP(안정성)로, 경쟁은 빠른 WebSocket(실시간성)으로 처리한다."**
두 가지 분리 전략은 서버의 부하를 효율적으로 분산시키고, 사용자에게는 끊김 없는 경험을 제공하는 최적의 타협점이다.

---

**2. 서버 게이트웨이 및 애플리케이션 계층 (Nginx, WSGI, ASGI)**

**적용한 아키텍처 개념**

- **Reverse Proxy (Nginx)** 도입
- **Sync(WSGI)와 Async(ASGI)의 분리**

**선택 근거 (왜 둘다 사용하고, 분리했나?)**

1. **Nginx (게이트웨이)**
   - **보안 및 효율:** Django(Gunicorn)가 외부 트래픽을 직접 받으면 정적 파일(이미지, CSS) 처리까지 CPU를 소모하게 되어 느려진다.
   - **교통 정리:** `/ws/` 경로는 ASGI로, 나머지는 WSGI로 보내는 라우팅 역할을 수행하여 백엔드 부하를 획기적으로 줄였다.

2. **WSGI (Gunicorn - 안정성 중심)**
   - **Pre-fork Model:** 멀티 프로세스 방식으로 하나의 워커가 죽어도 서비스가 중단되지 않는 높은 안정성을 보장한다. (결제 트랜잭션 처리에 필수)

3. **ASGI (Daphne/Uvicorn - 속도 중심)**
   - **비동기(Async):** 기존 WSGI는 웹소켓의 지속 연결을 처리하지 못한다. ASGI는 비동기 방식으로 수만 명의 연결을 유지하며 실시간 입찰(Push)을 가능하게 한다.

**결론**
단일 서버로 처리할 때 발생하는 **'안정성 vs 실시간성'의 딜레마를 서버 이원화(둘다 사용, 분리) 전략으로 해결**하였다.

**애플리케이션 서버 정리**

- **Gunicorn** : nginx 뒤에서 HTTP 요청을 Django에게 전달 <실제 서비스에서 안정적 서버 필요>

- **Uvicorn** : 비동기 처리 서비스에서 ASGI 앱 실행 <실시간성, 동시성 필요>

- **Daphne** : Django Channels와 함께 실행됨 <Django에서 WebSocket 쓰기 위해 필요>

---

**3. 이후 선택 근거 (왜 썼나?)**

1. **Redis (In-Memory)**
   - **문제:** Disk 기반의 DB(PostgreSQL)는 0.1초가 급한 경매 입찰 속도를 따라가지 못해 병목(BottleNeck)이 발생한다.

   - **해결:** RAM에서 동작하는 Redis를 사용하여 수백 배 빠른 읽기/쓰기를 보장하고, **Pub/Sub 기능**으로 실시간 메시지를 뿌리는 역할을 수행한다.

2. **Celery (Asynchronous Worker)**
   - **Non-blocking:** 입찰 후 DB 저장이나 이메일 발송 같은 무거운 작업에서 유저를 기다리게 해선 안 된다.
   - **역할:** "입찰 접수됨"을 즉시 응답하고, 무거운 뒷정리는 Celery가 백그라운드에서 비동기로 처리한다.

3. **PostgreSQL (RDBMS)**
   - **무결성(ACID):** Redis는 휘발성이므로, 최종적인 거래 데이터와 경매 결과는 가장 신뢰할 수 있는 관계형 DB인 PostgreSQL에 안전하게 보관한다.

**최종 결론**

이 아키텍처의 핵심은 **적재적소로 필요한 스택을 도입하여 안정성과 실시간성을 모두 잡는 것**이다.

**빠른 처리는 Redis와 ASGI가, 안전한 저장은 PostgreSQL과 WSGI가, 무거운 작업은 Celery가 나누어 맡는다.**

이를 통해 대규모 트래픽 상황에서도 **실시간성(Speed)**과 **안정성**이라는 두 마리 토끼를 모두 잡는 구조를 완성하였다.
